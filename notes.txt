1. First I made a randall folder using mkdir. Then, I downloaded the git repo that is linked on the assignment page using wget. Then the file can be unpacked using tar -xzvf randall-git.tgz. To see the code I did git reset --hard. Now i can see the randall.c file and the makefile

2. then I built the code in randall.c using make. This used gcc with the makefile to run it.The randall takes in 1 arg and outputs that number of randomly generated bytes. Some of these bytes need to be made visible by piping the output to see everything.

3. I implemented unit tests using check in the Makefile. They could look like @./randall 20 | wc -c | (grep -q "^20$$" && echo "PASSED") || (echo "FAILED" && false).

4. In this part we are breaking the randall.c file into several .c and header files. Each pair of files is handled handles a different feature of the program. Now we split files by hardware, software, output and options. Hardware files go to rand64-hw and software go to rand64-sw. Functions that are in charge of writing output go into output files and all the future options go into options files. Every time functions are moved the tests are created and ran to ensure that the program is still working as it was intended to. Include guards must be added to the headers so that things are not imported twice and we dont fall into circular dependency (We learnt this in CS 33). The headers should contain the struct and class declarations. Only the header should be included. .c files should never be included. This is because the headers should be the framework of the file and should contain everything needed by other files. Static local variables in c remain the same and do not lose what their values are between functional calls. Static global variables can only be accessed by functions within that .c file. Files outside that file will not be able to access the functions. Whenever we add a .c and .h fi;e we need to let gcc know. We can do this by modifying the makefile.

5. Getopt works like argparse in python in that it streamlines the handling of arguments in the standard input. TO use getopt we need to include unistd.h and bits/getopt_core.h. argc will equal the number of arguments ran with the command and argv should be a vector of all the arguments passed into the command in stdin including the command itself. ./randall -i arg1 -o arg2 would give argc = 5, arg[0] = ./randall, arg[1] = -i, arg[2] = arg1. Getopt() takes 3 arguments: argc, argv, and optstring. The optstring tells us what flags/options are available for the user to enter: 
- i, o, :, ?, default
set default values of input_source, output_type, nbytes
when optind >= argc. the last element of argv not arg but option
when getopt() detects this it will increment optind by 2 making it larger than or equal to the argc count
if option has no preceeding -i or -o it processes it as a number

6. modify i/o
first check for valid input output and nbytes.
No big changes needed for rdrand & stdio. we just need to check if it is supported and true in the main
handle_output needs to be modified by putting the initialize(), rand(), and finalize() functions into each branch of the if block so that different input modes can call different sets of initialization, randomization, and finalization functions
implement lrand48_r and mrand48_4 to generate random bits we want 64-bits so we call it twice. To implement n options for the output we modify the branches so that it contans the original code that writes the entire NBYTES in one try.

	10. Implementing N option for output

	• We modify the output branches in handle_output so that only the stdio branch contains the original code that writes the entire NBYTES length in one go
	• In the N branch
		○ We first check that N is actually a positive integer by passing it to strtol(output, &endptr, 10) 
			§ This function takes the char* output which is the N, an char* endptr, and the base (10) and returns a long int, which is the maxbytes or the maximum bytes that can be called by a single call of the write() function
		○ We can then malloc(maxbytes) a char* buffer of size maxbytes, in which we can store the bytes to be outputted
		○ We can then modify a version of the do-while loop in the stdio branch in our current branch by adding nested for loops that basically take from the random number (x) and generate bytes from it chunk-by-chunk by calling write(1, buffer, outbyte), which basically write to stdout outbytes many bytes from the buffer
			§ We also keep track of the remaining bytes that we have not printed yet by decrementing from NBYTES outbytes for every iteration
		○ We remember to free(buffer) at the end of all of this
	• We also add tests for N into Makefile
		○ We can use strace which prints to stdout a report of which system calls are used when a program (randall) is running
		○ strace ./randall 20 | grep --text write | wc -l tells us that the default options of randall calls write call once (1 line is outputted for 1 call of write)
		○ strace ./randall -o 100 1000 2>&1 | grep --text write | wc -l tells us that using the N option, randall calls write 10 times


11. Debugging and time testing
valgrind ./randall tests for memory leaks / errors
○ time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null gives
§ real    0m0.932s
§ user    0m0.014s
§ sys     0m0.912s
○ time ./randall 133562368 >/dev/null gives
§ real    0m3.931s
§ user    0m3.890s
§ sys     0m0.024s
○ time ./randall 133562368 | cat >/dev/null gives
§ real    0m4.204s
§ user    0m4.090s
§ sys     0m0.238s
○ time ./randall 133562368 >rand.data gives
§ real    0m4.117s
§ user    0m3.996s
§ sys     0m0.096s
